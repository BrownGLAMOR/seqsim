# Author: TJ Goff# # This class implements a client to participate in an auction on a remote host.# The client waits to receive a message from the host, and when a message is# received, the client should respond to the host with some information (such# as the clients bids in the auction).# # When the client starts, it will try to connect to the host at the IP and with# the port number specified in the text file IP_and_Port.txt (which should be in# the same folder as the client class).  This should allow you to easily change# the connection information to reach the host without having to recompile.# # You may choose to replace the line (91) which prompts the user for a unique name# with the commented line below it, which uses a hard-coded string for the name.# # You should enter your code for the following messages from the server:# 1: "agent-parameters:"  (initialize your agent with parameters from host)# 2: "submit-bid"         (return a string containing bids for slots 1-5 respectively)# (remember to separate bids with spaces!) # Remember to use the same formatting for output messages as the example code.## For help, contact: tom_goff@brown.edu import random #you may not need this...import socket#ADJUST THESE AS NEEDEDHOST = '192.168.40.1'    #remote hostPORT = 7              #Same port as used by the serverprint "AuctionClient started.  Attempting to connect to Server: "+HOST+", port: "+str(PORT)+"\n"#connect to host serverclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)client_socket.connect((HOST, PORT))print "Connection to host established\n"#store parameters about the auction and the clientnumSlotsNeeded = -1deadline = -1valuations = [] #we'll add valuations when we receive them from the server#the request/response loop... receive request, send a response to hostwhile 1:     fromServer = client_socket.recv(512)    if len(fromServer) < 2: #break if input is invalid        break    else:        print "Server: " + fromServer            #send a unique ID for this client    if "Send client name" in fromServer:        #YOUR CODE HERE!  name your own agent!        #//OPTIONAL CHANGE:        #//YOU MAY CHOOSE TO HARD CODE A NAME, OR PROMPT USER FOR NAME        myClientName = "Mr.Pink" #Why am I Mr.Pink?        myClientName = raw_input('Please enter a unique client name:') #prompt user for name                #remember to end all socket.send("whatever"+"\n") statements with newline: \n        sent = client_socket.send( myClientName+"\n" )                if sent == 0:            print "Cl was not sent..."        else:            print "User ID sent.  If prompted again, chose another ID/Name string."            print "Waiting for server to start auction..."                #receive client parameters from server    elif "agent-parameters:" in fromServer:        tokens = fromServer.split() #separates string into tokens, separated by spaces         numSlotsNeeded = int( tokens[1] )        deadline = int( tokens[2] )        #DEADLINE IS INDEX OF LAST AUCTION OF VALUE (0-indexed)        for i in range(3, len(tokens)):            valuations.append( tokens[i] )        print "Parameters set.  Valuations = "        print valuations            #///////////////////////////////////////////////        #//  YOUR CODE HERE        #//  You may want to store the parameters sent from host.        #//  For example, you could use them to initialize an         #//  agent class you wrote.        #///////////////////////////////////////////////                        #//EDIT HERE(?)                        #///////////////////////////////////////////////        client_socket.send( "Parameters accepted"+"\n" ) #let host know client received parameters                #Server wants you to reply with bid(s)    elif "submit-bid" in fromServer:        #///////////////////////////////////////////////        #//  YOUR CODE HERE        #//  Create a string, like myBids, with your bid(s).        #//  If placing multiple bids, separate bids with spaces spaces.        #//  If multiple bids, order bids as follows:        #//  myBids = "timeSlot1Bid  timeSlot2Bid ... timeslot5Bid";        #//        #//Note: bids rounded to 2 decimal places by host. 5.031 -> 5.03        #///////////////////////////////////////////////        myBids = "";                        #//EDIT HERE!        #END 1 BID FOR EACH TIME-SLOT (EVEN IF 0)        for i  in range(0, len(valuations)): #a bid for each time-slot        	myBids = myBids + str(random.random()*10) #random bid 0 to 10        	if i < len(valuations)-1:        		myBids = myBids + " " #separate bids with a space!  IMPORTANT!                		        #///////////////////////////////////////////////        client_socket.send( myBids+"\n" ) #Send agent's bids to server (DON'T FORGET NEWLINE!)        print "My bids: " + myBids;                    #Server sends the final outcome of the auction(s)    elif "observe-final-outcome:" in fromServer:        tokens = fromServer.split() #separates string into tokens, separated by spaces         for i in range(1, len(tokens), 2): #ignore first element: "observe-final-outcome". inc by 2            #for ith time-slot, winner and price        	winnerID = tokens[i];        	winPrice = float(tokens[i+1])        	print "Time Slot " + str((i+1)/2) + " awarded to [" + winnerID + "] for price = " + str(winPrice) + "\n"	        client_socket.send( "Final Outcome Observed"+"\n" ) #let host know outcomes were received(DON'T FORGET NEWLINE!)           else:        print "Unknown message received from host"        break                    print "Auction is over.  Closing connection.  Goodbye."client_socket.close()